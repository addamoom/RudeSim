---------The language constructs the simulator will support----------
Since i want to keep this simple the simulator will just support a small subset of vhdl to begin with.
The simulator will be very strict about how language constructs can look, to not waste time on generalising the parser but rather
fodus on the simulation, since thats what i wanted to figure out with this project.
Examples.
    - ALL Language constructs will be in CAPS.
    - VHDL statments with optional lables and verbosity will only have one form that can be parsed.
    - The IEEE library std_logic and std_logic_vector types are assumed part of the language.
    - Library statements can be parsed but will not be functional.

The complete list of supported constructs and how they must look can be seen in the src/vhdl.cf file
This is most of them i think:
    topdefenitions:
        entity, architecture, library declaration
        
    pre_begin_statements: 
        signal, constant, Component.
    
    post_begin_statements:
        concurrent_statements, port_maps.
        
    concurrent_statements:
        process, when, assignment, after_assignment. 
        
    seq_only_statements:
        case, if, wait_for, assignment.
        
    expressions:
        identifier, vector_refer, addition, subtraction, NOT.
    Data Types:
        std_logic, std_logic_vector, integer.
    timeunits:
        ps, ns, us, ms, s

more can be added later if desired.

-------How the simulator will work --------
The top file of the project is RudeSim.cpp
First the input file syntax is parsed using code generated by BNFC, Flex and Bison. The Syntax is determined by the src/vhdl.cf file.
If that is ok, the simulator proceeds to the next step, which is Typechecking the file. THis is done using a visitor pattern generated
by bnfc. We will probably not do very much here, rather leave it as a skeleton and assume the input is correct.
The same visitor pattern will be used heavily by the simulator i think. I imagine that the simulation will be done by iterating over the
visitor pattern for set time intervalls, eg do a simulation of 1000ns in steps of 1 ns. This might be rather resource heavy,
we will see i guess

When a simulation shoudl start the simulator first does a "state zero run" of the visitor pattern. It collects all the info of what
signals there is in a data structure and initialize them to either a init value given by the code or X. THis data structure is going to be
very important, so careful thought should probably be put into it. 

The next step is to start the actual simulation. THe pattern is run for each time sample. at a given time sample all info about what value
a signal has is stored in its own copy of the data structure from the "state zero" run. Since the file is read top to bottom all concurrent_statements might need to be run several
times in a time sample to ensure that they get a numerical value. 
Why? take the following concurrent assignments.
    b <= '1'
    a <= b
    c <= not d
    d <= '0'
It is clear to us that a, b and c will be 1 and d will be 0
However the simulaor will the first time it is run store:
    b = 1
    a = 1
    c = ?
    d = 0
the b is obvoius and can immidiaely be stored in the data structure. The next line it sees that a is assigned a symbol, so it searhes the
data structure and finds out if the symbol has a value, and it did.
the next line the c is assigned an expression. the simulator first checks if the expression is purely numerical. It isnt since 
it contains a symbol d. the simulator tries to search the data structure for a value of d but finds none. Therefore a numerical
value for c cannot yet be determined.  lastly d can ofcourse be assigned 0.

Then, the simulator checks the table to see if all symbols have a numerical value, and it dont. Therefore the concurrent 
statements are iterated again, and now all values should get a numerical value due to the data structure contaning more info than before.

When a data structure for a time sample is done the simulator moves on to the next time sample, and repeats the same as above.
When all data structures are done its time for wave generation. We do this by generating a VCD FILE, https://zipcpu.com/blog/2017/07/31/vcd.html
by iterating the data structures looking for changes. VCD is actually intended for verilog but i belive adapting it to vhdl isnt hard. 
The VCD file can then be displayed using GTKWave, and the simulator is finished.


-- Current Progress ---------------------------------------
2020-06-18
THe simulator have a parser and a skeleton for a typechecker.
THe abstract syntax appears to be correct in some cases, but no extensive tesing has been done.
For now i will jus work on simulating the simple file 

I think we will ignore processes at first, i havent thought out all the details about how they should work